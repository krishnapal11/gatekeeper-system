{{- $templateName := "k8suniqueserviceselector" }}
{{- $templateConfig := index .Values.constraintTemplates $templateName }}

{{- if $templateConfig.enabled }}
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: {{ $templateName }}
  labels:
    {{- include "gatekeeper.commonLabels" . | nindent 4 }}
  annotations:
    metadata.gatekeeper.sh/title: "Unique Service Selector"
    metadata.gatekeeper.sh/version: "1.0.2"
    metadata.gatekeeper.sh/requires-sync-data: |
      "[
        [
          {
            \"groups\": [\"\"],
            \"versions\": [\"v1\"],
            \"kinds\": [\"Service\"]
          }
        ]
      ]"
    description: >-
      Requires Services to have unique selectors within a namespace.
      Selectors are considered the same if they have identical keys and values.
      https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
spec:
  crd:
    spec:
      names:
        kind: K8sUniqueServiceSelector # Conventionally, it's PascalCase for Kind
      validation:
        legacySchema: false
        openAPIV3Schema:
          type: object
          description: "Ensures that selectors for Services are unique within a namespace. This constraint takes no parameters."
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8suniqueserviceselector

        # Helper to create a canonical, sorted, comma-separated string from a selector map
        # Returns empty string if no selector or selector is empty.
        flatten_selector(service_obj) = flattened_str {
          selector_map := object.get(object.get(service_obj, "spec", {}), "selector", {})
          count(object.keys(selector_map)) > 0 # Ensure selector is not empty

          # Create "key:value" strings
          selector_pairs := [sprintf("%v:%v", [key, value]) | key := object.keys(selector_map)[_]; value := selector_map[key]]
          
          # Sort and join for a canonical representation
          flattened_str := concat(",", sort(selector_pairs))
        } else = "" {
          # If selector is missing or empty, return an empty string
          true
        }

        violation[{"msg": msg, "details": {"conflicting_service_name": other_service_name, "namespace": review_namespace, "conflicting_selector": input_selector_str}}] {
          # This policy applies to v1/Service kinds
          input.review.kind.kind == "Service"
          input.review.kind.version == "v1"
          input.review.kind.group == "" # Core API group

          review_namespace := input.review.namespace
          current_service_name := input.review.object.metadata.name
          
          input_selector_str := flatten_selector(input.review.object)
          input_selector_str != "" # Only check for conflicts if the incoming service actually has a selector

          # Iterate over existing services in the same namespace from Gatekeeper's cache
          # data.inventory.namespace[<namespace>].service is a map where keys are service names
          other_service_name := object.keys(data.inventory.namespace[review_namespace].service)[_]
          other_service := data.inventory.namespace[review_namespace].service[other_service_name]

          # Don't compare the service with itself (e.g., during an update operation on the same service)
          current_service_name != other_service_name

          other_selector_str := flatten_selector(other_service)
          other_selector_str != "" # Only compare if the other service also has a selector
          
          input_selector_str == other_selector_str # Conflict if selectors are identical
          
          msg := sprintf("Service '%v' in namespace '%v' has a selector '%v' that conflicts with existing service '%v'. Selectors must be unique within a namespace.", [current_service_name, review_namespace, input_selector_str, other_service_name])
        }
{{- end }}
