# filename: k8s-unique-service-selector-template.yaml
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8suniqueserviceselector
  annotations:
    metadata.gatekeeper.sh/title: "Unique Service Selector"
    metadata.gatekeeper.sh/version: "1.0.2"
    metadata.gatekeeper.sh/requires-sync-data: |
      "[
        [
          {
            \"groups\": [\"\"],
            \"versions\": [\"v1\"],
            \"kinds\": [\"Service\"]
          }
        ]
      ]"
    description: >-
      Requires Services to have unique selectors within a namespace.
      Selectors are considered the same if they have identical keys and values.
      This prevents multiple Services from accidentally targeting the same set of Pods.
spec:
  crd:
    spec:
      names:
        kind: K8sUniqueServiceSelector # This is the Kind name used in the Constraint
      validation:
        # No parameters needed for this basic constraint, but schema must be object.
        legacySchema: false
        openAPIV3Schema:
          type: object
          description: "Ensures that selectors for Services are unique within a namespace. This constraint takes no parameters."
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8suniqueserviceselector

        # make_apiversion: Helper to construct the full apiVersion string.
        make_apiversion(kind_obj) = api_version {
          group := object.get(kind_obj, "group", "")
          version := object.get(kind_obj, "version", "")
          group != ""
          api_version = sprintf("%v/%v", [group, version])
        } else = api_version {
          api_version := object.get(kind_obj, "version", "")
        }

        # is_same_resource: Helper to identify if an inventory object is the one currently being reviewed.
        is_same_resource(obj_from_inventory, review_info) {
          obj_from_inventory.metadata.namespace == review_info.namespace
          obj_from_inventory.metadata.name == review_info.name
          obj_from_inventory.kind == review_info.kind.kind
          obj_from_inventory.apiVersion == make_apiversion(review_info.kind)
        }

        # flatten_selector: Converts a service's selector map into a canonical sorted string.
        # Returns an empty string if the selector is missing or empty.
        flatten_selector(service_obj) = flattened_str {
          selector_map := object.get(object.get(service_obj, "spec", {}), "selector", {})
          count(object.keys(selector_map)) > 0

          selector_pairs := [sprintf("%v:%v", [key, value]) |
                            key := object.keys(selector_map)[_];
                            value := selector_map[key]]

          flattened_str := concat(",", sort(selector_pairs))
        } else = "" {
          true
        }

        # violation: Defines when a Service selector is considered non-unique.
        violation[{"msg": msg, "details": {"conflictingService": other_service_name, "namespace": current_namespace, "conflictingSelector": current_service_selector_str}}] {
          # Target only core v1 Services.
          input.review.kind.kind == "Service"
          input.review.kind.version == "v1"
          input.review.kind.group == ""

          current_service := input.review.object
          current_namespace := input.review.namespace
          current_service_name := current_service.metadata.name

          # Get the current service's selector string. If empty, it can't conflict.
          current_service_selector_str := flatten_selector(current_service)
          current_service_selector_str != ""

          # Iterate through other Services in the same namespace from Gatekeeper's cache.
          other_service_name := object.keys(data.inventory.namespace[current_namespace].service)[_]
          other_service := data.inventory.namespace[current_namespace].service[other_service_name]

          # Ensure we are not comparing the service against itself (critical for updates).
          not is_same_resource(other_service, input.review)

          # Get the other service's selector string. Only compare if it also has a selector.
          other_service_selector_str := flatten_selector(other_service)
          other_service_selector_str != ""

          # If selectors are identical, a violation occurs.
          current_service_selector_str == other_service_selector_str

          msg := sprintf("Service '%v' in namespace '%v' has a selector '%v' that conflicts with existing service '%v'. Selectors must be unique within a namespace.", [current_service_name, current_namespace, current_service_selector_str, other_service_name])
        }
